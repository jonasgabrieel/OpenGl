#include <GL/glut.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>
#include <iostream>
#include <string>



#define MAX_DIMENSION 1000
GLfloat luz_pontual[] = {0.3, 0.5, 0.5, 1.0 };

#define IMAGE_WIDTH 256
#define IMAGE_HEIGHT 256


static GLubyte checkImage[IMAGE_HEIGHT][IMAGE_WIDTH][4];
static GLuint texName;

float cameraX = 0.0f;
float cameraY = 40.0f;
float cameraZ = 10.0f;


int** matrizImagem;
int largura;
int altura;

const char* carrinhoPath = "carro.obj"; // Caminho para o arquivo OBJ do carrinho
const float scaleFactor = 0.01f; // Fator de escala para ajustar o tamanho do modelo

void makeSandImage()
{
    for (int i = 0; i < IMAGE_HEIGHT; i++) {
        for (int j = 0; j < IMAGE_WIDTH; j++) {
            // Defina aqui as cores para a textura de areia
            GLubyte r = 237; // R: 237
            GLubyte g = 201; // G: 201
            GLubyte b = 175; // B: 175

            // Adiciona um ruído aleatório para simular granularidade
            r += rand() % 21 - 10; // Adiciona um valor aleatório entre -10 e 10
            g += rand() % 21 - 10; // Adiciona um valor aleatório entre -10 e 10
            b += rand() % 21 - 10; // Adiciona um valor aleatório entre -10 e 10

            // Certifique-se de que os valores de cor permaneçam dentro do intervalo válido (0-255)
            r = std::min<GLubyte>(255, std::max<GLubyte>(0, r));
            g = std::min<GLubyte>(255, std::max<GLubyte>(0, g));
            b = std::min<GLubyte>(255, std::max<GLubyte>(0, b));

            checkImage[i][j][0] = r;
            checkImage[i][j][1] = g;
            checkImage[i][j][2] = b;
            checkImage[i][j][3] = 255; // Opacidade máxima
        }
    }
}
void desenhar_luz(){
	
   glPushAttrib (GL_LIGHTING_BIT);
   
   GLfloat mat_diffuse[] = { 0.0, 1.0, 0.0, 1.0 };
   GLfloat mat_emission[] = { 1.0, 1.0, 0.0, 1.0 };
          
   //atribui características ao material
   glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
   glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);
 
   glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, mat_diffuse);
    
   glPushMatrix();
   glTranslatef(luz_pontual[0],luz_pontual[1],luz_pontual[2]); 
   glTranslatef(0.0, 0.0, 10.0); // Translada a esfera 2 unidades no eixo Z (aqui, estamos transladando-a para frente)

   
   glEnable(GL_LIGHTING);
   glColor3f (1.0, 1.0, 0.0);
   glutSolidSphere(0.5,50,50);
   glDisable(GL_LIGHTING);
   
   glPopAttrib();
   glPopMatrix();
}

void iluminar(){
   //LUZ
   // fontes de luz são iniciadas com cor preta
   // número de fontes de luz afeta performance
    
   //LUZ 0
  
   //define características a serem associadas à fonte de luz 0	
   //fonte de luz direcional (por que a coordenada homogênea w == 0?)
   GLfloat light0_position[] = { 0.0, 1.0, 0.0, 0.0 };
   GLfloat light0_diffuse[] = { 0.1, 0.1, 0.1, 1.0 };
   
   //atribui características para a fonte de luz 0
   //cor padrão: branco
   glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
   glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
   
   //LUZ 1
   
   //fonte de luz pontual (por que a coordenada homogênea w == 1?)
   //define características a serem associadas à fonte de luz 1	
   GLfloat light1_diffuse[] = { 0.0, 0.0, 0.0, 1.0 };
   GLfloat light1_specular[] = { 0.5, 0.5, 1.0, 1.0 };
   GLfloat light1_ambient[] = { 0.1, 0.1, 0.1, 1.0 };
   
   //atribui as características para a fonte de luz 1
   //(experimentem remover alguns dos componentes abaixo)
   glLightfv(GL_LIGHT1, GL_POSITION, luz_pontual);
   glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
   glLightfv(GL_LIGHT1, GL_SPECULAR, light1_specular);
   glLightfv(GL_LIGHT1, GL_AMBIENT, light1_ambient); 
   
   //"acende" cada uma das luzes configuradas
   glEnable(GL_LIGHT0);
   glEnable(GL_LIGHT1);
}



void renderModel(const aiScene* scene) {
    if (!scene) {
        std::cerr << "Erro ao carregar o modelo do carrinho." << std::endl;
        return;
    }
    
    float anguloRotacao = 90.0f; // Rotacionar o carrinho 90 graus em torno do eixo verde (Y)

    glPushMatrix(); // Inicie a matriz de transformação atual
    glPushAttrib(GL_CURRENT_BIT);
    glColor3f(1.0f,0.0f,0.0f);
    glRotatef(anguloRotacao, 0.0f, 1.0f, 0.0f);
    glRotatef(90.0f, 0.0, 0.0 , 1.0f);

    // GlTranslatef(Para os lados do terreno, Para cima e baixo, Para frente e tras);
    glTranslatef(20.0f, 1.0f, 6.0f);
    // Renderize o modelo do carrinho
    for (unsigned int i = 0; i < scene->mNumMeshes; ++i) {
        const aiMesh* mesh = scene->mMeshes[i];
        glBegin(GL_TRIANGLES);
        for (unsigned int j = 0; j < mesh->mNumFaces; ++j) {
            const aiFace& face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; ++k) {
                unsigned int index = face.mIndices[k];
                const aiVector3D& vertex = mesh->mVertices[index];
                glVertex3f(vertex.x * scaleFactor, vertex.y * scaleFactor, vertex.z * scaleFactor);
            }
        }
        glEnd();
    }
    glPopAttrib();
    glPopMatrix(); // Restaure a matriz de transformação anterior
}
void init(void) 
{
	glClearColor (0.0, 0.0, 0.0, 0.0);
	glShadeModel(GL_SMOOTH);
	
	glEnable(GL_DEPTH_TEST);
    makeSandImage();

    //declara um objeto de textura
	glGenTextures(1, &texName);
	
	//cria e usa objetos de textura 
	//podem ser trocados ou removidos (remoção: texName=0)
	glBindTexture(GL_TEXTURE_2D, texName);
	
	//todas as alterações feitas a seguir afetam o objeto associado
	//à textura
	
	//como a textura será tratada se não há mapeamento direto 
	//entre pixels e coordenadas de textura (GL_REPEAT ou GL_CLAMP)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
	
	//magnification e minification filters
	//GL_NEAREST: texel com coordenadas mais próximas do centro do pixel 
	//é usado
	//testar GL_LINEAR
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	
	//define uma textura bidimensional
	
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, IMAGE_WIDTH, 
	    IMAGE_HEIGHT, 0, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);


     // Ative a geração automática de coordenadas de textura para mapeamento esférico
    glEnable(GL_TEXTURE_GEN_S);
    glEnable(GL_TEXTURE_GEN_T);
    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);	
	    
	
}


int** lerImagemPGM(const char* nomeArquivo, int* largura, int* altura) {
    FILE *arquivo;
    char tipo[3];
    int maxValor;
    int i, j;

    arquivo = fopen(nomeArquivo, "r");

    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo.\n");
        return NULL;
    }

    fscanf(arquivo, "%s", tipo);

    if (tipo[0] != 'P' || tipo[1] != '2') {
        printf("Este código só suporta arquivos PGM no formato P2.\n");
        fclose(arquivo);
        return NULL;
    }

    fscanf(arquivo, "%d %d", largura, altura);
    fscanf(arquivo, "%d", &maxValor);

    if (*largura > MAX_DIMENSION || *altura > MAX_DIMENSION) {
        printf("A dimensão da imagem é muito grande para ser armazenada na matriz.\n");
        fclose(arquivo);
        return NULL;
    }

    int** matriz = (int**)malloc(*altura * sizeof(int*));

    for (i = 0; i < *altura; ++i) {
        matriz[i] = (int*)malloc(*largura * sizeof(int));
        for (j = 0; j < *largura; ++j) {
            fscanf(arquivo, "%d", &matriz[i][j]);
        }
    }

    fclose(arquivo);

    return matriz;
}


void display() {
    // Limpa o buffer de cor e o buffer de profundidade
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // Carrega a matriz de identidade para começar uma nova transformação
    glLoadIdentity();

    // Configura a câmera
    gluLookAt(cameraX, cameraY, cameraZ, 10.0, 0.0, 6.0, 0.0, 0.0, 5.0);

    // Ativa o uso de textura
    glEnable(GL_TEXTURE_2D);

    // Configura o modo de combinação da textura (nesse caso, GL_DECAL)
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

    // Define a textura atual como a textura de areia
    glBindTexture(GL_TEXTURE_2D, texName);

    // Configurar o material do carrinho
    GLfloat mat_ambient[] = {2.0f, 0.2f, 0.2f, 1.0f};
    GLfloat mat_diffuse[] = {0.8f, 0.8f, 0.8f, 0.5f};
    GLfloat mat_specular[] = {1.0f, 1.0f, 1.0f, 0.5f};
    GLfloat mat_shininess[] = {50.0f};

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    // Definir a cor do carrinho
    glColor3f(1.0f, 0.0f, 0.0f); // Vermelho

    // Cor das arestas dos triângulos (azul escuro)
    glColor3f(0.0f, 0.0f, 0.5f);
     Assimp::Importer importer;
    const aiScene* scene = importer.ReadFile(carrinhoPath, aiProcess_Triangulate | aiProcess_GenSmoothNormals);
    

    renderModel(scene);
    glDisable(GL_TEXTURE_2D);
    glutSwapBuffers();

glBegin(GL_TRIANGLES);
for (int i = 0; i < 39; ++i) {
    for (int j = 0; j < 39; ++j) {
        // Coordenadas dos vértices dos triângulos
        int x1 = i;
        int y1 = j;
        int x2 = i + 1;
        int y2 = j;
        int x3 = i;
        int y3 = j + 1;
        int x4 = i + 1;
        int y4 = j + 1;
        float z1 = matrizImagem[x1][y1];
        float z2 = matrizImagem[x2][y2];
        float z3 = matrizImagem[x3][y3];
        float z4 = matrizImagem[x4][y4];

        // Coordenadas de textura correspondentes aos vértices
        float u1 = static_cast<float>(x1) / 39.0f;
        float v1 = static_cast<float>(y1) / 39.0f;
        float u2 = static_cast<float>(x2) / 39.0f;
        float v2 = static_cast<float>(y2) / 39.0f;
        float u3 = static_cast<float>(x3) / 39.0f;
        float v3 = static_cast<float>(y3) / 39.0f;
        float u4 = static_cast<float>(x4) / 39.0f;
        float v4 = static_cast<float>(y4) / 39.0f;

        // Triângulo 1
        glTexCoord2f(u1, v1);
        glVertex3f(x1, y1, z1);
        glTexCoord2f(u2, v2);
        glVertex3f(x2, y2, z2);
        glTexCoord2f(u3, v3);
        glVertex3f(x3, y3, z3);

        // Triângulo 2
        glTexCoord2f(u2, v2);
        glVertex3f(x2, y2, z2);
        glTexCoord2f(u4, v4);
        glVertex3f(x4, y4, z4);
        glTexCoord2f(u3, v3);
        glVertex3f(x3, y3, z3);
    }
}
glEnd();

glDisable(GL_TEXTURE_2D);

            
    //visualização dos eixos
glBegin(GL_LINES);
    glColor3f (1.0, 0.0, 0.0);
    glVertex3f(0.0, 0.0, 0.0);
    glVertex3f(1.0, 0.0, 0.0);

    glColor3f (0.0, 1.0, 0.0);
    glVertex3f(0.0, 0.0, 0.0);
    glVertex3f(0.0, 1.0, 0.0);
  
    glColor3f (0.0, 0.0, 1.0);
    glVertex3f(0.0, 0.0, 0.0);
    glVertex3f(0.0, 0.0, 1.0);
glEnd();
 // Desativa o uso de textura
    glDisable(GL_TEXTURE_2D);

    // Troca o buffer de desenho com o buffer de exibição
    glutSwapBuffers();

    glFlush();
}

void reshape(int w, int h) {
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(40.0, (double)w / (double)h, 1.0, 100.0);
    glMatrixMode(GL_MODELVIEW);
}

void specialKeys(int key, int x, int y) {
    switch (key) {
    case GLUT_KEY_LEFT:
        cameraX -= 0.1f;
        break;
    case GLUT_KEY_RIGHT:
        cameraX += 0.1f;
        break;
    case GLUT_KEY_UP:
        cameraY += 0.1f;
        break;
    case GLUT_KEY_DOWN:
        cameraY -= 0.1f;
        break;
    }
    glutPostRedisplay();
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    matrizImagem = lerImagemPGM("imagem.ppm", &largura, &altura);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(500, 500);
    glutCreateWindow("Malha de Triângulos Vazados OpenGL");
    
    glEnable(GL_DEPTH_TEST);

    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutSpecialFunc(specialKeys);

    glutMainLoop();
    return 0;
}